import * as cheerio from 'cheerio';
import postcss, { Rule, Declaration } from 'postcss';
import { calculate as calcSpec } from 'specificity';

type CSSSource = { css: string, origin?: 'author' | 'user' | 'ua' }; // keep simple; treat all as author
type StyleMap = Record<string, string>;
type Spec = [number, number, number, number]; // inline,a,b,c

const INHERITABLE = new Set([
  // common inheritable properties; extend as needed
  'color', 'font', 'font-family', 'font-size', 'font-style', 'font-weight', 'letter-spacing',
  'line-height', 'text-align', 'text-indent', 'text-transform', 'visibility', 'white-space',
  'word-break', 'word-spacing', 'direction', 'cursor', 'list-style', 'list-style-type', 'list-style-position',
  'quotes', 'tab-size'
]);

// CSS initial values for a few common props; add more if you need them
const INITIALS: Record<string, string> = {
  color: 'CanvasText', // spec allows system color; browsers resolve to rgb(...)
  'font-weight': '400',
  'font-style': 'normal',
  'font-size': 'medium',
  'line-height': 'normal',
  'text-align': 'start',
  visibility: 'visible',
  'white-space': 'normal'
};

function specFromSelector(selector: string): Spec {
  // inline style gets [1,0,0,0]; others from package
  const s = calcSpec(selector)[0].specificityArray as [number, number, number, number];
  return s;
}
function cmpSpec(a: Spec, b: Spec): number {
  for (let i = 0; i < 4; i++) { if (a[i] !== b[i]) return a[i] - b[i]; }
  return 0;
}

type DeclEntry = {
  prop: string;
  value: string;
  important: boolean;
  spec: Spec;
  order: number; // increasing with stylesheet order
};

// parse author CSS into a flat declaration list per selector (preserving order)
function collectRules(sources: CSSSource[]) {
  const entries: { selector: string, decls: DeclEntry[] }[] = [];
  let order = 0;

  for (const src of sources) {
    const root = postcss.parse(src.css);
    root.walkRules((rule: Rule) => {
      const selectors = rule.selectors ?? [rule.selector];
      for (const sel of selectors) {
        const spec = specFromSelector(sel);
        const decls: DeclEntry[] = [];
        rule.walkDecls((d: Declaration) => {
          if (!d.prop || d.value == null) return;
          decls.push({
            prop: d.prop.trim().toLowerCase(),
            value: String(d.value).trim(),
            important: !!d.important,
            spec,
            order: order++
          });
        });
        if (decls.length) entries.push({ selector: sel, decls });
      }
    });
  }
  return entries;
}

// parse inline style quickly (fallback to PostCSS if you want full syntax)
function parseInlineStyle(style: string | undefined | null): DeclEntry[] {
  if (!style) return [];
  const decls: DeclEntry[] = [];
  const spec: Spec = [1, 0, 0, 0]; // inline
  let order = 1e9; // ensure after author rules
  for (const chunk of style.split(';')) {
    const i = chunk.indexOf(':');
    if (i <= 0) continue;
    const prop = chunk.slice(0, i).trim().toLowerCase();
    if (!prop) continue;
    let value = chunk.slice(i + 1).trim();
    let important = false;
    if (/\!important\s*$/i.test(value)) {
      important = true;
      value = value.replace(/\!important\s*$/i, '').trim();
    }
    decls.push({ prop, value, important, spec, order: order++ });
  }
  return decls;
}

// main: compute final (cascaded + inherited) styles for a single element
export function computeStylesForElement(
  $: cheerio.CheerioAPI,
  el: cheerio.Element,
  cssSources: CSSSource[],
  wantedProps?: string[] // if provided, limit to these
): StyleMap {
  const rules = collectRules(cssSources);

  // 1) Gather applicable declarations from stylesheets
  const applicable: DeclEntry[] = [];
  for (const r of rules) {
    if ($(el).is(r.selector)) {
      applicable.push(...r.decls);
    }
  }
  // 2) Add inline style (highest specificity)
  const inline = parseInlineStyle($(el).attr('style'));
  applicable.push(...inline);

  // 3) Cascade: pick best per property using (!important, spec, order)
  type Winner = { value: string; important: boolean; spec: Spec; order: number; };
  const cascaded = new Map<string, Winner>();

  const consider = (d: DeclEntry) => {
    if (wantedProps && !wantedProps.includes(d.prop)) return;
    const cur = cascaded.get(d.prop);
    if (!cur) { cascaded.set(d.prop, { value: d.value, important: d.important, spec: d.spec, order: d.order }); return; }
    // important first
    if (cur.important !== d.important) { if (d.important) cascaded.set(d.prop, { value: d.value, important: d.important, spec: d.spec, order: d.order }); return; }
    // higher specificity wins
    const s = cmpSpec(cur.spec, d.spec);
    if (s < 0) { cascaded.set(d.prop, { value: d.value, important: d.important, spec: d.spec, order: d.order }); return; }
    if (s > 0) return;
    // later wins
    if (cur.order <= d.order) cascaded.set(d.prop, { value: d.value, important: d.important, spec: d.spec, order: d.order });
  };
  for (const d of applicable) consider(d);

  // 4) Build result and handle inheritance
  const result: StyleMap = {};
  const propsToResolve = wantedProps
    ? new Set(wantedProps.map(p => p.toLowerCase()))
    : new Set<string>([...INHERITABLE, ...Array.from(cascaded.keys())]);

  for (const prop of propsToResolve) {
    const winner = cascaded.get(prop);
    if (winner) {
      result[prop] = winner.value;
      continue;
    }
    // inherit if applicable
    if (INHERITABLE.has(prop)) {
      const parent = el.parent && (el.parent as cheerio.Element);
      if (parent && parent.type === 'tag') {
        const parentStyles = computeStylesForElement($, parent, cssSources, [prop]);
        if (parentStyles[prop] != null) {
          result[prop] = parentStyles[prop];
          continue;
        }
      }
    }
    // fallback to initial
    if (INITIALS[prop] != null) result[prop] = INITIALS[prop];
  }

  return result;
}
